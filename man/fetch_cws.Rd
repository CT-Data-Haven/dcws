% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fetch_cws.R
\name{fetch_cws}
\alias{fetch_cws}
\title{Fetch and subset DCWS data}
\usage{
fetch_cws(..., .year = NULL, .name = NULL, .category = NULL, .unnest = FALSE)
}
\arguments{
\item{...}{Any number of conditions to filter by, which will be passed to \code{dplyr::filter}. These don't override the named options, so if you filter by \code{year > 2020} but then set \code{.year = 2015} you're not going to get any data.}

\item{.year}{A vector of one or more numbers giving the year(s) to subset by. If \code{NULL}, no filtering is done by year.}

\item{.name}{A vector of one or more strings giving the name(s) to subset by. If \code{NULL}, no filtering is done by name.}

\item{.category}{A vector of one or more strings giving the category(ies) to subset by. If \code{NULL}, no filtering is done by category.}

\item{.unnest}{Logical: should the \code{data} column be unnested? This just saves a step of calling \code{tidyr::unnest} but defaults to false.}
}
\value{
A data frame, with either 5 columns (if \code{.unnest = FALSE}) or 8 columns (if \code{.unnest = TRUE}).
\itemize{
\item For \code{.unnest = FALSE}: columns are \code{year}, \code{name}, \code{code}, \code{question}, and a list of nested data frames \code{data}
\item For \code{.unnest = TRUE}: \code{year}, \code{name}, \code{code}, \code{question}, \code{category}, \code{group}, \code{response}, and \code{value}
}
}
\description{
This function returns the doubly-nested data from \code{cws_full_data} in a nicer format, with options for subsetting. Filtering by year, location name, and category are named options, any of which take a vector of one or more values, but any valid conditions can be passed to \code{...} for more flexible filtering. For any named options, \code{NULL}, the default, will mean no filtering is done by that column.
}
\examples{
# no filtering
fetch_cws()

# filter by year, name, and/or category
fetch_cws(.name = c("Greater New Haven", "New Haven")) # all years
fetch_cws(.year = 2018, .name = c("Greater New Haven", "New Haven"))
fetch_cws(.year = 2021, .name = "New Haven", .category = c("Total", "Age", "Gender"))

# filter by conditions
fetch_cws(code == "Q4E", .year = 2018, .name = c("Greater New Haven", "New Haven"), .unnest = TRUE)
fetch_cws(grepl("Q4[A-Z]", code), .year = 2018, .name = c("Greater New Haven", "New Haven"))
fetch_cws(grepl("health insurance", question), year > 2015, .name = "New Haven")
fetch_cws(question \%in\% c("Diabetes", "Asthma"), .name = "Bridgeport")

# how you might use this to make a beautiful table
fetch_cws(code == "Q1", .year = 2021, .category = c("Income", "Gender"), .unnest = TRUE) \%>\%
  dplyr::group_by(name, category, group) \%>\%
  cwi::sub_nonanswers() \%>\%
  dplyr::filter(response == "Yes") \%>\%
  tidyr::pivot_wider(id_cols = name, names_from = group, values_from = value)
}
\seealso{
cws_full_data
}
