% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fetch_cws.R
\name{fetch_cws}
\alias{fetch_cws}
\title{Fetch and subset DCWS data}
\usage{
fetch_cws(
  ...,
  .year = NULL,
  .name = NULL,
  .category = NULL,
  .unnest = FALSE,
  .add_wts = FALSE
)
}
\arguments{
\item{...}{Any number of conditions to filter by, which will be passed to \code{dplyr::filter}. These don't override the named options, so if you filter by \code{year > 2020} but then set \code{.year = 2015} you're not going to get any data.}

\item{.year}{A vector of one or more numbers giving the year(s) to subset by. If \code{NULL}, no filtering is done by year.}

\item{.name}{A vector of one or more strings giving the name(s) to subset by. If \code{NULL}, no filtering is done by name.}

\item{.category}{A vector of one or more strings giving the category(ies) to subset by. If \code{NULL}, no filtering is done by category.}

\item{.unnest}{Logical: should the \code{data} column be unnested? This just saves a step of calling \code{tidyr::unnest} but defaults to false.}

\item{.add_wts}{Logical: should groups' survey weights be attached, via a left-join with \code{dcws::cws_full_wts}? This is useful if you need to collapse groups later; otherwise you might get stuck in annoying \code{tidyr::unnest} messes.}
}
\value{
A data frame, with between 5 and 9 columns, depending on arguments. Columns \code{year}, \code{name}, \code{code}, and \code{question} are always included. Additional columns:\tabular{ll}{
   arguments \tab columns \cr
   .unnest = F, .add_wts = F \tab data (nested df of category, group, response, and value) \cr
   .unnest = F, .add_wts = T \tab data (nested df of category, group, response, value, and weight) \cr
   .unnest = T, .add_wts = F \tab category, group, response, value \cr
   .unnest = T, .add_wts = T \tab category, group, response, value, weight \cr
}
}
\description{
This function returns the doubly-nested data from \code{cws_full_data} in a nicer format, with options for subsetting. Filtering by year, location name, and category are named options, any of which take a vector of one or more values, but any valid conditions can be passed to \code{...} for more flexible filtering. For any named options, \code{NULL}, the default, will mean no filtering is done by that column.
}
\examples{
# no filtering
fetch_cws()

# filter by year, name, and/or category
fetch_cws(.name = c("Greater New Haven", "New Haven")) # all years
fetch_cws(.year = 2018, .name = c("Greater New Haven", "New Haven"))
fetch_cws(.year = 2021, .name = "New Haven", .category = c("Total", "Age", "Gender"))

# filter by conditions
fetch_cws(code == "Q4E", .year = 2018, .name = c("Greater New Haven", "New Haven"), .unnest = TRUE)
fetch_cws(grepl("Q4[A-Z]", code), .year = 2018, .name = c("Greater New Haven", "New Haven"))
fetch_cws(grepl("health insurance", question), year > 2015, .name = "New Haven")
fetch_cws(question \%in\% c("Diabetes", "Asthma"), .name = "Bridgeport")

# how you might use this to make a beautiful table
fetch_cws(code == "Q1", .year = 2021, .category = c("Income", "Gender"), .unnest = TRUE) \%>\%
  dplyr::group_by(name, category, group) \%>\%
  cwi::sub_nonanswers() \%>\%
  dplyr::filter(response == "Yes") \%>\%
  tidyr::pivot_wider(id_cols = name, names_from = group, values_from = value)

# adding weights to collapse groups (e.g. combining income brackets)
fetch_cws(code == "Q1", .year = 2021, .add_wts = TRUE)
fetch_cws(.year = 2021, .name = "New Haven", .category = c("Total", "Age", "Income"),
          .add_wts = TRUE, .unnest = TRUE)
}
\seealso{
cws_full_data, cws_full_wts
}
